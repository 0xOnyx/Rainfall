let's strat buy start the software ./bonus1

./bonus1

segmentation fault 

so actually is need some argument so let's statr with a argument


└─$ ./bonus1 asss
                 
and is make nothing 

decompile the programme to watch wat's is happening :

.text:08048424 ; int __cdecl main(int argc, const char **argv, const char **envp)
.text:08048424                 public main
.text:08048424 main            proc near               ; DATA XREF: _start+17↑o
.text:08048424
.text:08048424 dest            = byte ptr -2Ch
.text:08048424 argc            = dword ptr  8
.text:08048424 argv            = dword ptr  0Ch
.text:08048424 envp            = dword ptr  10h
.text:08048424
.text:08048424 ; __unwind {
.text:08048424                 push    ebp
.text:08048425                 mov     ebp, esp
.text:08048427                 and     esp, 0FFFFFFF0h
.text:0804842A                 sub     esp, 40h
.text:0804842D                 mov     eax, [ebp+argv]
.text:08048430                 add     eax, 4
.text:08048433                 mov     eax, [eax]
.text:08048435                 mov     [esp], eax      ; nptr
.text:08048438                 call    _atoi
.text:0804843D                 mov     [esp+3Ch], eax
.text:08048441                 cmp     dword ptr [esp+3Ch], 9
.text:08048446                 jle     short loc_804844F
.text:08048448                 mov     eax, 1
.text:0804844D                 jmp     short locret_80484A3
.text:0804844F ; ---------------------------------------------------------------------------
.text:0804844F
.text:0804844F loc_804844F:                            ; CODE XREF: main+22↑j
.text:0804844F                 mov     eax, [esp+3Ch]
.text:08048453                 lea     ecx, ds:0[eax*4]
.text:0804845A                 mov     eax, [ebp+argv]
.text:0804845D                 add     eax, 8
.text:08048460                 mov     eax, [eax]
.text:08048462                 mov     edx, eax
.text:08048464                 lea     eax, [esp+40h+dest]
.text:08048468                 mov     [esp+8], ecx    ; n
.text:0804846C                 mov     [esp+4], edx    ; src
.text:08048470                 mov     [esp], eax      ; dest
.text:08048473                 call    _memcpy
.text:08048478                 cmp     dword ptr [esp+3Ch], 574F4C46h
.text:08048480                 jnz     short loc_804849E
.text:08048482                 mov     dword ptr [esp+8], 0
.text:0804848A                 mov     dword ptr [esp+4], offset arg ; "sh"
.text:08048492                 mov     dword ptr [esp], offset path ; "/bin/sh"
.text:08048499                 call    _execl
.text:0804849E
.text:0804849E loc_804849E:                            ; CODE XREF: main+5C↑j
.text:0804849E                 mov     eax, 0
.text:080484A3
.text:080484A3 locret_80484A3:                         ; CODE XREF: main+29↑j
.text:080484A3                 leave
.text:080484A4                 retn
.text:080484A4 ; } // starts at 8048424
.text:080484A4 main            endp



so only one function inside the main 


so le'ts deep dive into the code to watch wat's is make 


the first part is make a stack with a prologue to align and make a buffer of the stack on 64 octet

.text:08048424                 push    ebp
.text:08048425                 mov     ebp, esp
.text:08048427                 and     esp, 0FFFFFFF0h
.text:0804842A                 sub     esp, 40h


after is get the first argument inside the stack and put inside eax 
.text:0804842D                 mov     eax, [ebp+argv]
.text:08048430                 add     eax, 4
.text:08048433                 mov     eax, [eax]

is call atoi with the first element point by argv
.text:08048435                 mov     [esp], eax      ; nptr
.text:08048438                 call    _atoi


and put the result inside the stack a adresse  [esp+60]

.text:0804843D                 mov     [esp+3Ch], eax

and compare after the value with 9
.text:08048441                 cmp     dword ptr [esp+3Ch], 9
.text:08048446                 jle     short loc_804844F


jle = Jump if Less or Equal
Si [esp+3Ch] <= 9 → jump to loc_804844F


if is not correct put 1 inside eax and jump to the end of the stack
.text:08048448                 mov     eax, 1
.text:0804844D                 jmp     short locret_80484A3



if is correct is go to this part of the code :

the function
.text:0804844F loc_804844F:                            ; CODE XREF: main+22↑j

so is get the variable from atoi before and make a * 4 
.text:0804844F                 mov     eax, [esp+3Ch]
.text:08048453                 lea     ecx, ds:0[eax*4]
and store the value inside ecx

after is get the second argument of the argv 
.text:0804845A                 mov     eax, [ebp+argv]
.text:0804845D                 add     eax, 8

deference the value to get the value inside the addresse
.text:08048460                 mov     eax, [eax]
.text:08048462                 mov     edx, eax
and put the value inside edx 

get the buffer from stack at address 
.text:08048464                 lea     eax, [esp+20]

so the buffer is 40 octet !


64  esp


44 ----- esp + 20

   char a[40]

4  ----- esp - 60
    int b
0 ----- ebp





call from is copy 4 * argv[1] and copy from argv[2]
.text:08048468                 mov     [esp+8], ecx    ; n
.text:0804846C                 mov     [esp+4], edx    ; src
.text:08048470                 mov     [esp], eax      ; dest
.text:08048473                 call    _memcpy


is compare if the value of the int store in esp +60 is equal to 1464814662 
.text:08048478                 cmp     dword ptr [esp+3Ch], 574F4C46h
.text:08048480                 jnz     short loc_804849E

if is correct is launch a new instance of sh binarie
.text:08048482                 mov     dword ptr [esp+8], 0
.text:0804848A                 mov     dword ptr [esp+4], offset arg ; "sh"
.text:08048492                 mov     dword ptr [esp], offset path ; "/bin/sh"
.text:08048499                 call    _execl
.text:0804849E
.text:0804849E loc_804849E:                            ; CODE XREF: main+5C↑j



ok how to exploit is really simple 
you need to copye more value from argv2 more than 40 octet the restult is overflow 
the value store inside the stack at esp-60


you need to put 44 octet inside the buffer so 44 / 4 = 11 octet 
but because is check the value is more leess than 9 is not possible

so how to bypass ?

 actully make * 4  is juste make a bit shift 

 so the solution is two use a number negatif after bit shift is equal two 44

 so 4 octet is 8 x 4 = 32 octet 

To represent a negative integer in binary:
1) Write its absolute value in binary.
2) Invert all the bits (bitwise NOT).
3) Add 1.

what the value of 11 ?

0000 0000 0000 0000 0000 0000 0000 1011


os is 1011 with 28 zero 

so you need a negatif value when is bit shift to two is equal to that


so the first two bit is possible to change 

1000 0000 0000 0000 0000 0000 0000 1011 => −2,147,483,637 => 0x8000000B

so now i have negatif value 

so now when is bet shift to the left 2 

the value is 
0000 0000 0000 0000 0000 0000 0010 1100 => 44

and is 44 !!! perfect is now is bypass 


and after is only to create a buffer of 44 octet with the last 4 octet
with the content of the comparaison so here 1464814662

and let's go !

flag :
579bd19263eb8655e4cf7b742d75edf8c38226925d78db8163506f5191825245